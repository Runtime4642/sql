
## 인덱스 (Indexes)
인덱스는 데이터베이스 검색 속도를 높이는 데 사용됩니다. 인덱스는 특정 열에 대한 데이터를 빠르게 조회할 수 있도록 돕습니다.

### 인덱스의 구조
- **Hash 구조**: 해시 테이블을 사용하여 데이터를 저장하고 검색하는 방식
  - **장점**: 검색 속도가 매우 빠름, 등호(=) 연산에 최적화됨
  - **단점**: 범위 검색에 적합하지 않음, 메모리 사용량이 큼

- **B-Tree 구조**: 이진 트리와 유사한 구조로 데이터를 정렬하여 저장하는 방식
  - **장점**: 범위 검색에 적합, 삽입과 삭제가 비교적 용이
  - **단점**: 검색 속도가 Hash 구조에 비해 느림

- **B+ Tree 구조**: B-Tree 구조의 변형으로 리프 노드에만 데이터를 저장하는 방식
  - **장점**: 범위 검색에 매우 적합, 순차 접근이 용이
  - **단점**: 구현이 복잡, 검색 속도가 Hash 구조에 비해 느림

### B+ Tree의 추가 설명
B+ Tree는 B-Tree의 변형으로, 모든 실제 데이터는 리프 노드에만 저장되며, 내부 노드에는 데이터에 대한 포인터와 키 값만 저장됩니다. 리프 노드들은 포인터를 통해 연결 리스트 형태로 연결되어 있어 순차 접근이 용이합니다. 이는 특히 범위 검색에 유리한 구조입니다. 예를 들어, 특정 범위의 값을 검색할 때, 시작점만 찾으면 이후의 노드를 순차적으로 탐색할 수 있습니다.


### B-Tree
- **노드(Node)**: 데이터를 저장하는 공간.
  - **내부 노드(Internal Node)**: 트리의 중간에 있는 노드들. 데이터와 함께 자식 노드들에 대한 포인터를 가지고 있음.
  - **리프 노드(Leaf Node)**: 트리의 맨 아래에 있는 노드들. 자식 노드가 없고, 데이터만 가지고 있음.
- **트리(Tree)**: 데이터가 계층 구조로 저장된 구조.

### B+ Tree
- B-Tree와 비슷하지만 중요한 차이가 있음.
- **내부 노드(Internal Node)**: 데이터가 아니라 데이터의 위치(키)만 가지고 있음. 자식 노드들에 대한 포인터를 가지고 있음.
- **리프 노드(Leaf Node)**: 모든 실제 데이터를 저장하고, 리프 노드끼리 연결되어 있음.

## 예시로 이해하기

### B-Tree의 구조
- 상상해보세요: 우리가 도서관에서 책을 찾으려고 해요.
- B-Tree에서는 각 층(노드)에 책이 있고, 중간 층(내부 노드)에도 책이 있어요.
- 중간 층(내부 노드)에 있는 책은 다음 층으로 가는 길을 가르쳐줘요.
- 그래서 책을 찾으려면 여러 층을 오르락내리락해야 해요.

### B+ Tree의 구조
- B+ Tree에서는 중간 층(내부 노드)에는 책의 위치(키)만 있어요.
- 모든 책은 맨 아래 층(리프 노드)에만 있어요.
- 리프 노드들은 서로 연결되어 있어서, 한 번 리프 노드에 도착하면 그 다음 책들을 순서대로 쉽게 찾을 수 있어요.

## 왜 B+ Tree가 더 빠를까요?
1. **중간 층이 더 가볍다**: B+ Tree의 중간 층(내부 노드)에는 책의 위치만 있어서 더 많은 위치 정보를 담을 수 있어요. 그래서 층이 얕아져서 책을 찾는 길이 짧아져요.
2. **리프 노드의 연결**: 리프 노드들이 서로 연결되어 있어서, 한 번 리프 노드에 도착하면 그 다음 책들을 순서대로 쉽게 찾을 수 있어요. 범위 검색에 특히 유리해요.

## 요약
- **B-Tree**: 중간 층(내부 노드)과 맨 아래 층(리프 노드) 모두에 책이 있어요.
- **B+ Tree**: 중간 층(내부 노드)에는 책의 위치만 있고, 모든 책은 맨 아래 층(리프 노드)에만 있어요. 리프 노드끼리 연결되어 있어서 한 번 찾으면 그 다음은 쉽게 찾을 수 있어요.



### 인덱스가 빠른 이유
인덱스는 데이터를 정렬된 구조로 저장하기 때문에 검색 연산의 복잡도를 낮춥니다. 일반적으로, 인덱스를 사용하면 데이터 검색 속도가 O(log n)으로 줄어들어, 선형 검색(O(n))보다 훨씬 빠릅니다.

### 많은 인덱스를 추가하면 안 좋은 이유
- **성능 저하**: 많은 인덱스를 유지 관리하는 데 드는 오버헤드가 커집니다. 데이터 삽입, 업데이트, 삭제 시마다 인덱스를 갱신해야 하므로 성능이 저하될 수 있습니다.
- **공간 낭비**: 인덱스를 저장하는 데 추가적인 저장 공간이 필요합니다. 많은 인덱스는 디스크 공간을 많이 차지할 수 있습니다.
- **복잡성 증가**: 너무 많은 인덱스는 데이터베이스 구조를 복잡하게 만들고 관리하기 어려워질 수 있습니다.

### 인덱스 생성 예시
```
CREATE INDEX 인덱스명
ON 테이블명 (열1);
```

위의 예시는 테이블명에 있는 열1에 대해 인덱스를 생성하는 SQL 문입니다.
